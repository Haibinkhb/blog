[
    {
        "id": "prototype",
        "title": "JavaScript原型和原型链",
        "tag": "JavaScript",
        "body": "<h4 id=\"原型\">原型</h4>\n<hr>\n<p>
        \nfunction Person(){</p>\n<p>
        };\nPerson.prototype.name = ‘cxk’; // 只有函数才会有prototype属性\nlet p1 = new Person();\nlet p2 = new Person();\nconsole.log(p1.name, p2.name)   // cxk, cxk\n</p>\n<p>上面代码中创建了一个构造函数 Person ,然后使用 new (或者说是：“普通”函数 Person 使用 new 关键字来构造调用?)创建了两个实例对象(p1, p2)。</p>\n<p>绝大部分函数都有一个 prototype 属性,它会指向一个对象，它指向的这个对象就是实例的原型。也就是说上例中的 Person 构造函数的 prototype 属性的值就是 p1, p2 的原型。</p>\n<h4 id=\"__proto__\">__proto__</h4>\n<hr>\n<p>每一个 JavaScript 对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。</p>\n<p>
            \nfunction Person() {</p>\n<p>
        }\nlet p = new Person();\nconsole.log(p.<strong>proto</strong> === Person.prototype); // true\n</p>\n<p>当读取实例的属性时，如果找不到，就会去查找和对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。就像例 1 中 p1, p2 都没有定义 name 属性，查找的时候找不到就会去找原型( Person.prototype )中找，所以返回的都是 “cxk”。如下：</p>\n<p>
        \nfunction Person() {</p>\n<p>
        }\nlet p1 = new Person();\nlet p2 = new Person();\nPerson.prototype.name = ‘cxk’;\np1.name = ‘wyf’;\nconsole.log(p1.name, p2.name) // wyf, cxk\n</p>\n<h4 id=\"原型的原型\">原型的原型</h4>\n<hr>\n<p>前面说到读取实例的属性时如果找不到会去原型中查找，如果还找不到，就去找原型的原型… 原型的原型又是什么？</p>\n<p>前面说过函数的 prototype 属性指向的是一个对象，也就是说原型是一个对象，所以它也有一个 __proto__ 属性,这个属性会指向该对象的原型…那还有完没完？</p>\n<p><code>js\nlet obj = new Object();\nobj.name = &#39;cxk&#39;\nconsole.log(obj.name) // cxk</code></p>\n<p>我们知道通过 JavaScript 内置的构造函数 Object 可以创建对象，其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以最终会查找到 Object.prototype.__proto__ 为止。那 Object.prototype.__proto__的值又是什么呢？</p>\n<p><code>js\nconsole.log(Object.prototype.__proto__) // null</code></p>\n<p>盗一张图关系图… :\n<img src=\"https://raw.githubusercontent.com/mqyqingfeng/Blog/master/Images/prototype5.png\" alt=\"原型链\" title=\"原型链\"></p>\n<p>蓝色的线就是原型链</p>\n<h4 id=\"constructor\">constructor</h4>\n<hr>\n<p>constructor 是什么鬼？</p>\n<p>是原型对象上的一个属性。他会指向关联的构造函数。也就是说每一个构造函数上的 prototype 属性指向的原型对象上会有一个 constructor 属性指向关联的构造函数。</p>\n<p>
            \nfunction Person() {</p>\n<p>
        }\nconsole.log(Person === Person.prototype.constructor); // true\n</p>\n<p>参考：</p>\n<ul>\n<li>你不知道的JavaScript（上卷）</li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/2\">JavaScript深入之从原型到原型链</a></li>\n</ul>\n<p>图片来源：</p>\n<ul>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/2\">JavaScript深入之从原型到原型链</a></li>\n</ul>\n",
        "updatedAt": "2019-11-15T07:04:07.487Z"
    },
    {
        "id": "scope",
        "title": "JavaScript作用域",
        "tag": "JavaScript",
        "body": "<h4 id=\"作用域\">作用域</h4>\n<hr>\n<blockquote>\n<p>作用域是指源代码定义变量的区域。作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\n<em><a href=\"https://github.com/mqyqingfeng/Blog/issues/3\">JavaScript深入之词法作用域和动态作用域</a></em></p>\n</blockquote>\n<p>JavaScript采用词法作用域（静态作用域），函数的作用域在函数定义时就已经确定了。</p>\n<p><code>js\nvar scope = &quot;global&quot;;\nfunction checkscope(){\n    var scope = &quot;local&quot;;\n    function f(){\n        return scope;\n    }\n    return f();\n}\ncheckscope();</code></p>\n<p><code>js\nvar scope = &quot;global&quot;;\nfunction checkscope(){\n    var scope = &quot;local&quot;;\n    function f(){\n        return scope;\n    }\n    return f;\n}\ncheckscope()();</code></p>\n<p>这两段代码都会输出： local</p>\n<p>因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。</p>\n<blockquote>\n<p>JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。\n<em>《JavaScript权威指南》</em></p>\n</blockquote>\n<h4 id=\"javascript代码的执行顺序\">JavaScript代码的执行顺序</h4>\n<hr>\n",
        "updatedAt": "2019-11-15T07:04:12.560Z"
    }
]